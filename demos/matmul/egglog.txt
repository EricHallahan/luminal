; -------- SYMBOLIC ALGEBRA -------
(ruleset expr)
(datatype Expression
	(MNum i64)
	(MVar String)
	(MAdd Expression Expression)
	(MSub Expression Expression)
	(MMul Expression Expression)
	(MDiv Expression Expression)
	(MMod Expression Expression)
	(MMin Expression Expression)
	(MMax Expression Expression)
	(MAnd Expression Expression)
	(MOr Expression Expression)
	(MGte Expression Expression)
	(MLt Expression Expression)
	(MFloorTo Expression Expression)
    (MReplace Expression Expression Expression)
    (MAccum String) ; this marks that we feed the output (also marked with MAccum) back in
)

; Communative
(rewrite (MAdd a b) (MAdd b a) :ruleset expr)
(rewrite (MMul a b) (MMul b a) :ruleset expr)

; Associative
(rewrite (MAdd (MAdd a b) c) (MAdd a (MAdd b c)) :ruleset expr)
(rewrite (MMul (MMul a b) c) (MMul a (MMul b c)) :ruleset expr)

; Constant folding
(rewrite (MAdd (MNum a) (MNum b)) (MNum (+ a b)) :ruleset expr)
(rewrite (MSub (MNum a) (MNum b)) (MNum (- a b)) :ruleset expr)
(rewrite (MMul (MNum ?a) (MNum ?b)) (MNum (* ?a ?b)) :when ((< ?a 10000) (< ?b 10000)) :ruleset expr)
(rewrite (MDiv (MNum a) (MNum b)) (MNum (/ a b)) :when ((!= 0 b) (= 0 (% a b))) :ruleset expr)
(rewrite (MMax (MNum a) (MNum b)) (MNum (max a b)) :ruleset expr)
(rewrite (MMin (MNum a) (MNum b)) (MNum (min a b)) :ruleset expr)
(rewrite (MAnd (MNum a) (MNum b)) (MNum (& a b)) :ruleset expr)

; Simple reductions
(rewrite (MAdd a (MNum 0)) a :ruleset expr)
(rewrite (MMul a (MNum 1)) a :ruleset expr)
(rewrite (MMul a (MNum 0)) (MNum 0) :ruleset expr)
(rewrite (MDiv a (MNum 1)) a :ruleset expr)
(rewrite (MMod (MMul ?x ?y) ?y) (MNum 0) :ruleset expr)
(rewrite (MMod (MMod ?x (MNum ?y)) (MNum ?z)) (MMod ?x (MNum ?y)) :when ((>= ?z ?y) (= 0 (% ?y ?z))) :ruleset expr) ; nested mods
(rewrite (MMod (MMod ?x (MNum ?y)) (MNum ?z)) (MMod ?x (MNum ?z)) :when ((>= ?y ?z) (= 0 (% ?z ?y))) :ruleset expr)

; Replacement
(rewrite (MReplace ?x ?y ?z) ?z :when ((= ?x ?y)) :ruleset expr)
(rewrite (MReplace (MAdd ?a ?b) ?x ?y) (MAdd (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)) :ruleset expr)
(rewrite (MReplace (MSub ?a ?b) ?x ?y) (MSub (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)) :ruleset expr)
(rewrite (MReplace (MMul ?a ?b) ?x ?y) (MMul (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)) :ruleset expr)
(rewrite (MReplace (MDiv ?a ?b) ?x ?y) (MDiv (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)) :ruleset expr)
(rewrite (MReplace (MMod ?a ?b) ?x ?y) (MMod (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)) :ruleset expr)
(rewrite (MReplace (MMin ?a ?b) ?x ?y) (MMin (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)) :ruleset expr)
(rewrite (MReplace (MMax ?a ?b) ?x ?y) (MMax (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)) :ruleset expr)
(rewrite (MReplace (MFloorTo ?a ?b) ?x ?y) (MFloorTo (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)) :ruleset expr)
; leave numbers unchanged
(rewrite (MReplace (MNum ?n) ?x ?y) (MNum ?n) :ruleset expr)
(rewrite (MReplace (MAccum ?acc) ?x ?y) (MAccum ?acc) :ruleset expr)

; leave other vars unchanged
(rewrite (MReplace (MVar ?v) (MVar ?x) ?y) (MVar ?v) :when ((!= ?v ?x)) :ruleset expr)

; -------- IR --------
(ruleset ir)
(ruleset ir-prop)
(ruleset ir-generic)
(datatype LoopType (Loop String Expression))
(datatype IR
	; General kernel stuff
   	(GMEM String)
   	(LoopIn IR LoopType Expression)
   	(LoopOut IR LoopType Expression)
   	(SMEM)
   	(SMEMLoad IR IR)
    (SMEMRead IR IR)

    ; Unary Ops
   	(Exp2 IR)
   	(Log2 IR)
   	(Sqrt IR)
   	(Sin IR)
   	(Recip IR)
   	(Neg IR)

    ; Binary Ops
   	(Add IR IR)
   	(Mul IR IR)
   	(Max IR IR)

    ; search helpers
    (Unary String IR)
   	(Binary String IR IR)

   	; propogation patterns
   	(SwapLoops IR String String) ; Swap two loops, identified by their strings
   	(TileLoop IR String) ; Tile a loop, identified by it's string
    (UnpadLoop IR String) ; Remove a padding loop, identified by it's string
    (MergeLoops IR String String) ; Merge loops, identified by their strings
    (Fused IR) ; Says that we have previously fused a loopout -> loopin here

   	; propogation pattern helpers
   	(PropOneArg String IR String) ; Generic prop one arg back
   	(PropTwoArgs String IR String String) ; Generic prop two args back

   	; tensor core stuff
   	(TCMatmul IR IR Expression Expression Expression Expression Expression Expression) ; input A, input B, A k stride, B k stride, A inner stride, B inner stride, C inner stride, number of K tile loops
   	(TiledMatmulInputA String i64 Expression)
    (TiledMatmulInputB String i64 Expression)
)

; -------------- HELPERS ---------------

; Convert to and from generic unary ops
(birewrite (Exp2 ?x) (Unary "Exp2" ?x) :ruleset ir-generic)
(birewrite (Log2 ?x) (Unary "Log2" ?x) :ruleset ir-generic)
(birewrite (Sqrt ?x) (Unary "Sqrt" ?x) :ruleset ir-generic)
(birewrite (Sin ?x) (Unary "Sin" ?x) :ruleset ir-generic)
(birewrite (Recip ?x) (Unary "Recip" ?x) :ruleset ir-generic)
(birewrite (Neg ?x) (Unary "Neg" ?x) :ruleset ir-generic)
(birewrite (Add ?a ?b) (Binary "Add" ?a ?b) :ruleset ir-generic)
(birewrite (Mul ?a ?b) (Binary "Mul" ?a ?b) :ruleset ir-generic)
(birewrite (Max ?a ?b) (Binary "Max" ?a ?b) :ruleset ir-generic)

; Communative binary ops
(rewrite (Binary ?bin ?a ?b) (Binary ?bin ?b ?a) :ruleset ir)
; distributive/associative skeletons so sums and products re-associate
(rewrite (Add (Add ?a ?b) ?c) (Add ?a (Add ?b ?c)) :ruleset ir)
(rewrite (Mul (Mul ?a ?b) ?c) (Mul ?a (Mul ?b ?c)) :ruleset ir)

; set containing maccums
(sort ExpressionSetBase (Set Expression))

; a single global set, merged by union
(function MAccumSet () ExpressionSetBase
  :merge (set-union old new))

; for every (MAccum ...), add that exact term to the set
(rule ((= ?e (MAccum ?s)))
  ((set (MAccumSet) (set-of ?e)))
  :ruleset ir-prop)

; ---------- RULES ----------

; remove pad loop
(rewrite
 	(LoopOut (Unary ?un (LoopIn ?x (Loop ?loop (MNum 1)) (MNum 0))) (Loop ?loop (MNum 1)) (MNum 0))
	(Unary ?un ?x)
	 ;:ruleset ir
)
(rewrite
 	(LoopOut (Binary ?bin (LoopIn ?a (Loop ?loop (MNum 1)) (MNum 0)) (LoopIn ?b (Loop ?loop (MNum 1)) (MNum  0))) (Loop ?loop (MNum 1)) (MNum 0))
	(Binary ?bin ?a ?b)
	 ;:ruleset ir
)
; add pad loop
(rewrite
	(LoopOut (Unary ?un ?x) (Loop ?l ?r) ?s)
	(LoopOut (LoopOut (Unary ?un (LoopIn ?x (Loop "newpad" (MNum 1)) (MNum 0))) (Loop "newpad" (MNum 1)) (MNum 0)) (Loop ?l ?r) ?s)
	:when ((!= ?r (MNum 1)) (!= ?s (MNum 0)))
	;:ruleset ir
)
(rewrite
	(LoopOut (Binary ?bin ?a ?b) (Loop ?l ?r) ?s)
	(LoopOut (LoopOut (Binary ?bin (LoopIn ?a (Loop "newpad" (MNum 1)) (MNum 0)) (LoopIn ?b (Loop "newpad" (MNum 1)) (MNum 0))) (Loop "newpad" (MNum 1)) (MNum 0)) (Loop ?l ?r) ?s)
	:when ((!= ?r (MNum 1)) (!= ?s (MNum 0)))
	;:ruleset ir
)


; Loop Fusion
(rewrite
	(LoopIn (LoopOut (Binary ?bin ?a ?b) (Loop ?loopA ?range) ?st) (Loop ?loopB ?range) ?st)
	(Fused (Binary ?bin ?a ?b))
	:ruleset ir
)
(rewrite
	(LoopIn (LoopIn
		(LoopOut (LoopOut (Binary ?bin ?a ?b) (Loop ?loopA1 ?range1) ?st1) (Loop ?loopA2 ?range2) ?st2)
	(Loop ?loopB2 ?range2) ?st2) (Loop ?loopB1 ?range1) ?st1)
	(Fused (Binary ?bin ?a ?b))
	 :ruleset ir
)
(rewrite
	(LoopIn (LoopIn (LoopIn
		(LoopOut (LoopOut (LoopOut
			(Binary ?bin ?a ?b)
		(Loop ?loopA1 ?range1) ?st1) (Loop ?loopA2 ?range2) ?st2) (Loop ?loopA3 ?range3) ?st3)
	(Loop ?loopB3 ?range3) ?st3) (Loop ?loopB2 ?range2) ?st2) (Loop ?loopB1 ?range1) ?st1)
	(Fused (Binary ?bin ?a ?b))
	:ruleset ir
)

; Tiling
(rewrite
	(LoopOut ?body (Loop ?loop (MNum ?range)) ?stride)
	(LoopOut
		(LoopOut
			(TileLoop ?body ?loop)
			(Loop (+ ?loop "_tile") (MNum 8))
			?stride
		)
		(Loop (+ ?loop "_out") (MNum (/ ?range 8)))
		(MReplace ?stride (MVar "z") (MMul (MVar "z") (MNum 8)))
	)
	:when ((> ?range 8) (= (% ?range 8) 0))
	:ruleset ir
)
(rewrite
	(TileLoop (LoopIn ?body (Loop ?loop (MNum ?range)) ?stride) ?loop)
	(LoopIn
		(LoopIn ?body
			(Loop (+ ?loop "_out") (MNum (/ ?range 8)))
			(MReplace ?stride (MVar "z") (MMul (MVar "z") (MNum 8)))
		)
		(Loop (+ ?loop "_tile") (MNum 8))
		?stride
	)
	:ruleset ir-prop
)
; propogation
(rewrite
	(TileLoop (LoopIn ?body (Loop ?other ?range) ?stride) ?loop)
	(LoopIn (TileLoop ?body ?loop) (Loop ?other ?range) ?stride)
	:when ((!= ?loop ?other))
	:ruleset ir-prop
)
(rewrite
	(TileLoop (LoopOut ?body (Loop ?other ?range) ?stride) ?loop)
	(LoopOut (TileLoop ?body ?loop) (Loop ?other ?range) ?stride)
	 :ruleset ir-prop
)
(rewrite
	(TileLoop (Unary ?un ?body) ?loop)
	(Unary ?un (TileLoop ?body ?loop))
	 :ruleset ir-prop
)
(rewrite
	(TileLoop (Binary ?bin ?bodyA ?bodyB) ?loop)
	(Binary ?bin (TileLoop ?bodyA ?loop) (TileLoop ?bodyB ?loop))
	 :ruleset ir-prop
)


; Loop merging
(rewrite
	(LoopOut
		(LoopOut ?x
			(Loop ?i (MNum ?rangeI)) ?stI
		)
		(Loop ?o (MNum ?rangeO)) ?stO
	)
	(LoopOut (MergeLoops ?x ?o ?i)
		(Loop (+ ?o (+ "merge" ?i)) (MNum (* ?rangeO ?rangeI)))
		(MAdd (MReplace ?stO (MVar "z") (MDiv (MVar "z") (MNum ?rangeI))) (MReplace ?stI (MVar "z") (MMod (MVar "z") (MNum ?rangeI))))
	)
	:when ((set-not-contains (MAccumSet) ?stI) (set-not-contains (MAccumSet) ?stO))
	:ruleset ir
)
(rewrite
	(MergeLoops
		(LoopIn
			(LoopIn
				?x
				(Loop ?o ?rangeO) ?stO
			)
			(Loop ?i ?rangeI) ?stI
		)
		?o ?i
	)
	(LoopIn
		?x
		(Loop (+ ?o (+ "merge" ?i)) (MMul ?rangeO ?rangeI))
		(MAdd (MReplace ?stO (MVar "z") (MDiv (MVar "z") ?rangeI)) (MReplace ?stI (MVar "z") (MMod (MVar "z") ?rangeI)))
	)
	 :ruleset ir-prop
)
; propogation
(rewrite
	(MergeLoops (LoopIn ?body (Loop ?other ?range) ?stride) ?o ?i)
	(LoopIn (MergeLoops ?body ?o ?i) (Loop ?other ?range) ?stride)
	:when ((!= ?i ?other))
	:ruleset ir-prop
)
(rewrite
	(MergeLoops (LoopOut ?body (Loop ?other ?range) ?stride) ?o ?i)
	(LoopOut (MergeLoops ?body ?o ?i) (Loop ?other ?range) ?stride)
	 :ruleset ir-prop
)
(rewrite
	(MergeLoops (Unary ?un ?body) ?o ?i)
	(Unary ?un (MergeLoops ?body ?o ?i))
	 :ruleset ir-prop
)
(rewrite
	(MergeLoops (Binary ?bin ?bodyA ?bodyB) ?o ?i)
	(Binary ?bin (MergeLoops ?bodyA ?o ?i) (MergeLoops ?bodyB ?o ?i))
	 :ruleset ir-prop
)

; TensorCore
(ruleset tc)
(rewrite
	(LoopIn ; k
		(LoopIn ; n
			(LoopIn ; m
				(GMEM ?a)
				(Loop ?loop_a_mtile (MNum ?m))
				(MMul (MVar "z") (MNum ?k))
			)
			(Loop ?loop_a_ntile (MNum ?n))
			(MNum 0)
		)
		(Loop ?loop_a_kouter (MNum ?k))
		(MVar "z")
	)
	(TiledMatmulInputA ?a ?k (MNum (/ ?k 8)))
	:when ((= (% ?k 8) 0) (= (% ?m 8) 0) (= (% ?n 8) 0))
	:ruleset tc
)
(rewrite
	(LoopIn ; k
		(LoopIn ; n
			(LoopIn ; m
				(GMEM ?b)
				(Loop ?loop_b_mtile (MNum ?m))
				(MNum 0)
			)
			(Loop ?loop_b_ntile (MNum ?n))
			(MVar "z")
		)
		(Loop ?loop_b_kouter (MNum ?k))
		(MMul (MVar "z") (MNum ?n))
	)
	(TiledMatmulInputB ?b ?n (MNum (/ ?k 8)))
	:when ((= (% ?k 8) 0) (= (% ?m 8) 0) (= (% ?n 8) 0))
	:ruleset tc
)
(rewrite
	(LoopOut ; m
		(LoopOut ; n
			 (LoopOut ; k
				(Add
					(Fused (Mul
						(TiledMatmulInputA ?a ?k ?k_loops)
						(TiledMatmulInputB ?b ?n ?k_loops)
					))
					; accumulator
					(LoopIn ; k outer
						(LoopIn ; n tile
							(LoopIn ; m tile
								?acc
								(Loop ?loop_acc_mtile (MNum ?m))
								(MNum 0)
							)
							(Loop ?loop_acc_ntile (MNum ?n))
							(MNum 0)
						)
						(Loop ?loop_acc_k (MNum ?k))
						(MAccum ?accum)
					)
				)
				(Loop ?loop_out_k (MNum ?k))
				(MAccum ?acc_outer)
			)
			(Loop ?loop_out_n (MNum ?n))
			(MVar "z")
		)
		(Loop ?loop_out_m (MNum ?m))
		(MMul (MVar "z") (MNum ?n))
	)
	(LoopOut ; m outer
		(LoopOut ; n outer
			(LoopOut ; m tile
				(LoopOut ; n tile
					(TCMatmul
						; a
						(LoopIn ; n tile
							(LoopIn ; m tile
								(LoopIn ; n outer
									(LoopIn ; m outer
										(GMEM ?a)
										(Loop ?loop_out_m (MNum (/ ?m 8)))
										(MMul (MVar "z") (MNum (* ?k 8)))
									)
									(Loop ?loop_out_n (MNum (/ ?n 8)))
									(MNum 0)
								)
								(Loop (+ ?loop_out_m "_tile") (MNum 8))
								(MNum 0)
							)
							(Loop (+ ?loop_out_n "_tile") (MNum 4))  ; each thread in the matmul does 2 elements
							(MNum 0)
						)
						; b
						(LoopIn ; n tile
							(LoopIn ; m tile
								(LoopIn ; n outer
									(LoopIn ; m outer
										(GMEM ?b)
										(Loop ?loop_out_m (MNum (/ ?m 8)))
										(MNum 0)
									)
									(Loop ?loop_out_n (MNum (/ ?n 8)))
									(MMul (MVar "z") (MNum 8))
								)
								(Loop (+ ?loop_out_m "_tile") (MNum 8))
								(MNum 0)
							)
							(Loop (+ ?loop_out_n "_tile") (MNum 4))  ; each thread in the matmul does 2 elements
							(MNum 0)
						)
						; a k stride
						(MMul (MVar "z") (MNum 8))
						; b k stride
						(MMul (MVar "z") (MNum (* ?n 8)))
						; a row size
						(MNum ?k)
						; b row size
						(MNum ?n)
						; c row size
						(MNum ?n)
						; k loops
						?k_loops
					)
					(Loop (+ ?loop_out_n "_tile") (MNum 4))
					(MNum 0)
				)
				(Loop (+ ?loop_out_m "_tile") (MNum 8))
				(MNum 0)
			)
			(Loop ?loop_out_n (MNum (/ ?n 8)))
			(MMul (MVar "z") (MNum 8))
		)
		(Loop ?loop_out_m (MNum (/ ?m 8)))
		(MMul (MVar "z") (MNum (* ?n 8)))
	)
	:ruleset tc
)

; Swap loops
(rewrite
	(LoopOut
		(LoopOut
			?x
			(Loop ?innerLoop ?innerRange)
			?innerStride
		)
		(Loop ?outerLoop ?outerRange)
		?outerStride
	)
	(LoopOut
		(LoopOut
			(SwapLoops
				?x
				?innerLoop
				?outerLoop
			)
			(Loop ?outerLoop ?outerRange)
			?outerStride
		)
		(Loop ?innerLoop ?innerRange)
		?innerStride
	)
	:when ((set-not-contains (MAccumSet) ?innerStride) (!= ?innerLoop ?outerLoop))
	;:ruleset ir
)
(rewrite
	(SwapLoops
		(LoopIn
			(LoopIn
				?x
				(Loop ?outerLoop ?outerRange)
				?outerStride
			)
			(Loop ?innerLoop ?innerRange)
			?innerStride
		)
		?innerLoop
		?outerLoop
	)
	(LoopIn
		(LoopIn
			?x
			(Loop ?innerLoop ?innerRange)
			?innerStride
		)
		(Loop ?outerLoop ?outerRange)
		?outerStride
	)
	:ruleset ir-prop
)
; propogate
(rewrite
	(SwapLoops (LoopOut ?x ?loop ?stride) ?innerLoop ?outerLoop)
	(LoopOut (SwapLoops ?x ?innerLoop ?outerLoop) ?loop ?stride)
	:ruleset ir-prop
)
(rewrite
	(SwapLoops (LoopIn ?x (Loop ?loop ?range) ?stride) ?innerLoop ?outerLoop)
	(LoopIn (SwapLoops ?x ?innerLoop ?outerLoop) (Loop ?loop ?range) ?stride)
	:when ((!= ?loop ?innerLoop))
	:ruleset ir-prop
)
(rewrite
	(SwapLoops (Unary ?un ?a) ?innerLoop ?outerLoop)
	(Unary ?un (SwapLoops ?a ?innerLoop ?outerLoop))
	:ruleset ir-prop
)
(rewrite
	(SwapLoops (Binary ?bin ?a ?b) ?innerLoop ?outerLoop)
	(Binary ?bin (SwapLoops ?a ?innerLoop ?outerLoop) (SwapLoops ?b ?innerLoop ?outerLoop))
	:ruleset ir-prop
)

(let t0 (GMEM "B Load"))
(let t1 (GMEM "A Load"))
(let t2 (LoopIn t0 (Loop "0" (MNum 512)) (MNum 0)))
(let t3 (LoopIn t2 (Loop "1" (MNum 512)) (MVar "z")))
(let t4 (LoopIn t3 (Loop "2" (MNum 512)) (MMul (MNum 512) (MVar "z"))))
(let t5 (LoopIn t1 (Loop "0" (MNum 512)) (MMul (MNum 512) (MVar "z"))))
(let t6 (LoopIn t5 (Loop "1" (MNum 512)) (MNum 0)))
(let t7 (LoopIn t6 (Loop "2" (MNum 512)) (MVar "z")))
(let t8 (Mul t4 t7))
(let t9 (LoopOut t8 (Loop "2" (MNum 512)) (MVar "z")))
(let t10 (LoopOut t9 (Loop "1" (MNum 512)) (MMul (MVar "z") (MNum 512))))
(let t11 (LoopOut t10 (Loop "0" (MNum 512)) (MMul (MMul (MVar "z") (MNum 512)) (MNum 512))))
(let t12 (GMEM "acc_0"))
(let t13 (LoopIn t11 (Loop "0" (MNum 512)) (MMul (MNum 262144) (MVar "z"))))
(let t14 (LoopIn t13 (Loop "1" (MNum 512)) (MMul (MNum 512) (MVar "z"))))
(let t15 (LoopIn t14 (Loop "2" (MNum 512)) (MVar "z")))
(let t16 (LoopIn t12 (Loop "0" (MNum 512)) (MNum 0)))
(let t17 (LoopIn t16 (Loop "1" (MNum 512)) (MNum 0)))
(let t18 (LoopIn t17 (Loop "2" (MNum 512)) (MAccum "a")))
(let t19 (Add t15 t18))
(let t20 (LoopOut t19 (Loop "2" (MNum 512)) (MAccum "a")))
(let t21 (LoopOut t20 (Loop "1" (MNum 512)) (MVar "z")))
(let t22 (LoopOut t21 (Loop "0" (MNum 512)) (MMul (MVar "z") (MNum 512))))

(run-schedule
	(saturate ir-generic)
	(saturate expr)
	(repeat 2
		(run ir)
		(saturate ir-prop)
		(saturate expr)
	)
	(saturate ir-generic)
	(saturate tc)
)

;(ruleset loop-blank)
;(rewrite (Loop ?s ?r) (Loop "" ?r) :ruleset loop-blank)
;(rewrite (MergeLoops ?x ?r ?y) (MergeLoops ?x "" "") :ruleset loop-blank)
;(run-schedule (run loop-blank))
