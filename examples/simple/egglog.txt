; -------- SYMBOLIC ALGEBRA -------

(datatype Expression
	(MNum i64)
	(MVar String)
	(MAdd Expression Expression)
	(MSub Expression Expression)
	(MMul Expression Expression)
	(MDiv Expression Expression)
	(MMod Expression Expression)
	(MMin Expression Expression)
	(MMax Expression Expression)
	(MAnd Expression Expression)
	(MOr Expression Expression)
	(MGte Expression Expression)
	(MLt Expression Expression)
	(MFloorTo Expression Expression)
    (MReplace Expression Expression Expression)
    (MAccum String) ; this marks that we feed the output (also marked with MAccum) back in
)

; Associative
(rewrite (MAdd (MAdd a b) c) (MAdd a (MAdd b c)))
(rewrite (MMul (MMul a b) c) (MMul a (MMul b c)))

; Constant folding
(rewrite (MAdd (MNum a) (MNum b)) (MNum (+ a b)))
(rewrite (MSub (MNum a) (MNum b)) (MNum (- a b)))
(rewrite (MMul (MNum a) (MNum b)) (MNum (* a b)) :when ((< a 10000) (< b 10000)))
(rewrite (MDiv (MNum a) (MNum b)) (MNum (/ a b)) :when ((!= 0 b) (= 0 (% a b))))
(rewrite (MMax (MNum a) (MNum b)) (MNum (max a b)))
(rewrite (MMin (MNum a) (MNum b)) (MNum (min a b)))
(rewrite (MAnd (MNum a) (MNum b)) (MNum (& a b)))

; Simple reductions
(rewrite (MAdd a (MNum 0)) a)
(rewrite (MMul a (MNum 1)) a)
(rewrite (MMul a (MNum 0)) (MNum 0))
(rewrite (MDiv a (MNum 1)) a)
(rewrite (MMul (MDiv ?a ?b) ?b) (MFloorTo ?a ?b))
(rewrite (MAdd (MFloorTo ?a ?b) (MMod ?a ?b)) ?a)

; Replacement
(rewrite (MReplace ?x ?y ?z) ?z :when ((= ?x ?y)))
(rewrite (MReplace (MAdd ?a ?b) ?x ?y) (MAdd (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)))
(rewrite (MReplace (MSub ?a ?b) ?x ?y) (MSub (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)))
(rewrite (MReplace (MMul ?a ?b) ?x ?y) (MMul (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)))
(rewrite (MReplace (MDiv ?a ?b) ?x ?y) (MDiv (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)))
(rewrite (MReplace (MMod ?a ?b) ?x ?y) (MMod (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)))
(rewrite (MReplace (MMin ?a ?b) ?x ?y) (MMin (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)))
(rewrite (MReplace (MMax ?a ?b) ?x ?y) (MMax (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)))
(rewrite (MReplace (MFloorTo ?a ?b) ?x ?y) (MFloorTo (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)))
;; leave numbers unchanged
(rewrite (MReplace (MNum ?n) ?x ?y) (MNum ?n))
(rewrite (MReplace (MAccum ?acc) ?x ?y) (MAccum ?acc))

;; leave other vars unchanged
(rewrite (MReplace (MVar ?v) (MVar ?x) ?y) (MVar ?v) :when ((!= ?v ?x)))

; -------- IR --------

(datatype LoopType (Loop String Expression))
(datatype*
 	(IR
  		; General kernel stuff
     	(GMEM String)
     	(LoopIn IR LoopType Expression)
     	(LoopOut IR LoopType Expression)
      	(SMEM)
       	(SMEMLoad IR IR)
        (SMEMRead IR IR)

        ; Unary Ops
     	(Exp2 IR)
      	(Log2 IR)
    	(Sqrt IR)
     	(Sin IR)
      	(Recip IR)
       	(Neg IR)

        ; Binary Ops
     	(Add IR IR)
     	(Mul IR IR)
      	(Max IR IR)

        ; search helpers
        (Unary String IR)
     	(Binary String IR IR)

      	; propogation patterns
      	(SwapLoops IR String String) ; Swap two loops, identified by their strings
       	(TileLoop IR String) ; Tile a loop, identified by it's string
        (UnpadLoop IR String) ; Remove a padding loop, identified by it's string
        (MergeLoops IR String String) ; Merge loops, identified by their strings

    	; propogation pattern helpers
     	(PropOneArg String IR String) ; Generic prop one arg back
     	(PropTwoArgs String IR String String) ; Generic prop two args back
     )
)

; -------------- HELPERS ---------------

; Convert to and from generic unary ops
(rewrite (Exp2 ?x) (Unary "Exp2" ?x))
(rewrite (Unary "Exp2" ?x) (Exp2 ?x))
(rewrite (Log2 ?x) (Unary "Log2" ?x))
(rewrite (Unary "Log2" ?x) (Log2 ?x))
(rewrite (Sqrt ?x) (Unary "Sqrt" ?x))
(rewrite (Unary "Sqrt" ?x) (Sqrt ?x))
(rewrite (Sin ?x) (Unary "Sin" ?x))
(rewrite (Unary "Sin" ?x) (Sin ?x))
(rewrite (Recip ?x) (Unary "Recip" ?x))
(rewrite (Unary "Recip" ?x) (Recip ?x))
(rewrite (Neg ?x) (Unary "Neg" ?x))
(rewrite (Unary "Neg" ?x) (Neg ?x))
(rewrite (Add ?a ?b) (Binary "Add" ?a ?b))
(rewrite (Binary "Add" ?a ?b) (Add ?a ?b))
(rewrite (Mul ?a ?b) (Binary "Mul" ?a ?b))
(rewrite (Binary "Mul" ?a ?b) (Mul ?a ?b))
(rewrite (Max ?a ?b) (Binary "Max" ?a ?b))
(rewrite (Binary "Max" ?a ?b) (Max ?a ?b))
; propogation patterns
(rewrite (SwapLoops ?expr ?a ?b) (PropTwoArgs "SwapLoops" ?expr ?a ?b))
(rewrite (PropTwoArgs "SwapLoops" ?expr ?a ?b) (SwapLoops ?expr ?a ?b))
(rewrite (TileLoop ?expr ?loop) (PropOneArg "TileLoop" ?expr ?loop))
(rewrite (PropOneArg "TileLoop" ?expr ?loop)  (TileLoop ?expr ?loop))
(rewrite (UnpadLoop ?expr ?loop) (PropOneArg "UnpadLoop" ?expr ?loop))
(rewrite (PropOneArg "UnpadLoop" ?expr ?loop)  (UnpadLoop ?expr ?loop))
(rewrite (MergeLoops ?expr ?loopA ?loopB) (PropTwoArgs "MergeLoops" ?expr ?loopA ?loopB))
(rewrite (PropTwoArgs "MergeLoops" ?expr ?loopA ?loopB)  (MergeLoops ?expr ?loopA ?loopB))

; propogation helpers
(rewrite
	(PropOneArg ?prop (LoopIn ?body (Loop ?other ?range) ?stride) ?arg)
	(LoopIn (PropOneArg ?prop ?body ?arg) (Loop ?other ?range) ?stride)
)
(rewrite
	(PropOneArg ?prop (LoopOut ?body (Loop ?other ?range) ?stride) ?arg)
	(LoopOut (PropOneArg ?prop ?body ?arg) (Loop ?other ?range) ?stride)
)
(rewrite
	(PropOneArg ?prop (Unary ?un ?body) ?arg)
	(Unary ?un (PropOneArg ?prop ?body ?arg))
)
(rewrite
	(PropOneArg ?prop (Binary ?bin ?bodyA ?bodyB) ?arg)
	(Binary ?bin (PropOneArg ?prop ?bodyA ?arg) (PropOneArg ?prop ?bodyB ?arg))
)
(rewrite
	(PropTwoArgs ?prop (LoopIn ?body (Loop ?other ?range) ?stride) ?arg1 ?arg2)
	(LoopIn (PropTwoArgs ?prop ?body ?arg1 ?arg2) (Loop ?other ?range) ?stride)
)
(rewrite
	(PropTwoArgs ?prop (LoopOut ?body (Loop ?other ?range) ?stride) ?arg1 ?arg2)
	(LoopOut (PropTwoArgs ?prop ?body ?arg1 ?arg2) (Loop ?other ?range) ?stride)
)
(rewrite
	(PropTwoArgs ?prop (Unary ?un ?body) ?arg1 ?arg2)
	(Unary ?un (PropTwoArgs ?prop ?body ?arg1 ?arg2))
)
(rewrite
	(PropTwoArgs ?prop (Binary ?bin ?bodyA ?bodyB) ?arg1 ?arg2)
	(Binary ?bin (PropTwoArgs ?prop ?bodyA ?arg1 ?arg2) (PropTwoArgs ?prop ?bodyB ?arg1 ?arg2))
)

; Communative binary ops
;(rewrite (Binary ?bin ?a ?b) (Binary ?bin ?b ?a))
; distributive/associative skeletons so sums and products re-associate
;(rewrite (Add (Add ?a ?b) ?c) (Add ?a (Add ?b ?c)))
;(rewrite (Mul (Mul ?a ?b) ?c) (Mul ?a (Mul ?b ?c)))

; ---------- RULES ----------

; remove pad loop
(rewrite
 	(LoopOut (Unary ?un (LoopIn ?x (Loop ?loop (MNum 1)) (MNum 0))) (Loop ?loop (MNum 1)) (MNum 0))
	(Unary ?un ?x)
)
(rewrite
 	(LoopOut (Binary ?bin (LoopIn ?a (Loop ?loop (MNum 1)) (MNum 0)) (LoopIn ?b (Loop ?loop (MNum 1)) (MNum  0))) (Loop ?loop (MNum 1)) (MNum 0))
	(Binary ?bin ?a ?b)
)
; add pad loop
(rewrite
	(LoopOut (Unary ?un ?x) (Loop ?l ?r) ?s)
	(LoopOut (LoopOut (Unary ?un (LoopIn ?x (Loop "newpad" (MNum 1)) (MNum 0))) (Loop "newpad" (MNum 1)) (MNum 0)) (Loop ?l ?r) ?s)
	:when ((!= ?r (MNum 1)) (!= ?s (MNum 0)))
)
(rewrite
	(LoopOut (Binary ?bin ?a ?b) (Loop ?l ?r) ?s)
	(LoopOut (LoopOut (Binary ?bin (LoopIn ?a (Loop "newpad" (MNum 1)) (MNum 0)) (LoopIn ?b (Loop "newpad" (MNum 1)) (MNum 0))) (Loop "newpad" (MNum 1)) (MNum 0)) (Loop ?l ?r) ?s)
	:when ((!= ?r (MNum 1)) (!= ?s (MNum 0)))
)
(rewrite
	(LoopOut (Binary ?bin2 (Binary ?bin ?a ?b) ?c) (Loop ?l ?r) ?s)
	(LoopOut (LoopOut (Binary ?bin2 (Binary ?bin (LoopIn ?a (Loop "newpad" (MNum 1)) (MNum 0)) (LoopIn ?b (Loop "newpad" (MNum 1)) (MNum 0))) (LoopIn ?c (Loop "newpad" (MNum 1)) (MNum 0))) (Loop "newpad" (MNum 1)) (MNum 0)) (Loop ?l ?r) ?s)
	:when ((!= ?r (MNum 1)) (!= ?s (MNum 0)))
)

; Loop Fusion
(rewrite (LoopIn (LoopOut ?x (Loop ?loopA ?range) ?st) (Loop ?loopB ?range) ?st) ?x)

; Specialized swap loops

; Tiling
(rewrite
	(LoopOut ?body (Loop ?loop (MNum ?range)) ?stride)
	(LoopOut
		(LoopOut
			(TileLoop ?body ?loop)
			(Loop (+ ?loop "_tile") (MNum 8))
			?stride
		)
		(Loop ?loop (MNum (/ ?range 8)))
		(MReplace ?stride (MVar "z") (MMul (MVar "z") (MNum 8)))
	)
	:when ((> ?range 8) (= (% ?range 8) 0))
)
(rewrite
	(TileLoop (LoopIn ?body (Loop ?loop (MNum ?range)) ?stride) ?loop)
	(LoopIn (LoopIn ?body (Loop ?loop (MNum (/ ?range 8))) (MReplace ?stride (MVar "z") (MMul (MVar "z") (MNum 8)))) (Loop (+ ?loop "_tile") (MNum 8)) ?stride)
	:when ((> ?range 8) (= (% ?range 8) 0))
)
; Merging
(rewrite
 	(LoopOut (LoopOut ?ir (Loop ?innerL ?inner) ?innerStride) (Loop ?outerL ?outer) ?outerStride)
 	(LoopOut (MergeLoops ?ir ?innerL ?outerL)
     	(Loop (+ ?outerL ?innerL) (MMul ?inner ?outer))
		(MAdd (MReplace ?outerStride (MVar "z") (MDiv (MVar "z") ?inner)) (MReplace ?innerStride (MVar "z") (MMod (MVar "z") ?inner)))
    )
)
(rewrite (MergeLoops (LoopIn (LoopIn ?ir (Loop ?outerL ?outer) ?outerStride) (Loop ?innerL ?inner) ?innerStride) ?innerL ?outerL)
	(LoopIn ?ir
		(Loop (+ ?outerL ?innerL) (MMul ?inner ?outer))
		(MAdd (MReplace ?outerStride (MVar "z") (MDiv (MVar "z") ?inner)) (MReplace ?innerStride (MVar "z") (MMod (MVar "z") ?inner)))
	)
)

(let t0 (GMEM "acc_0"))
(let t1 (LoopIn t0 (Loop "0" (MMul (MNum 6) (MVar "b"))) (MNum 0)))
(let t2 (LoopIn t1 (Loop "-pad1-" (MNum 1)) (MNum 0)))
(let t3 (LoopIn t2 (Loop "-pad2-" (MNum 1)) (MNum 0)))
(let t4 (LoopIn t3 (Loop "-pad3-" (MNum 1)) (MNum 0)))
(let t5 (LoopIn t4 (Loop "-pad4-" (MNum 1)) (MNum 0)))
(let t6 (LoopIn t5 (Loop "4" (MNum 2)) (MAccum "a")))
(let t7 (GMEM "A Load"))
(let t8 (LoopIn t7 (Loop "0" (MMul (MVar "b") (MNum 12))) (MAdd (MMul (MNum 4) (MMod (MDiv (MVar "z") (MMax (MMul (MNum 4) (MVar "b")) (MNum 1))) (MNum 3))) (MAdd (MMul (MNum 2) (MMod (MDiv (MVar "z") (MMax (MMul (MNum 2) (MVar "b")) (MNum 1))) (MNum 2))) (MMod (MVar "z") (MNum 2))))))
(let t9 (GMEM "B Load"))
(let t10 (LoopIn t9 (Loop "0" (MMul (MVar "b") (MNum 12))) (MAdd (MMod (MDiv (MVar "z") (MNum 2)) (MVar "b")) (MMul (MVar "b") (MAdd (MMod (MVar "z") (MNum 2)) (MMul (MNum 2) (MMod (MDiv (MVar "z") (MMax (MMul (MVar "b") (MNum 4)) (MNum 1))) (MNum 3))))))))
(let t11 (Mul t8 t10))
(let t12 (LoopOut t11 (Loop "0" (MMul (MMul (MNum 6) (MVar "b")) (MNum 2))) (MVar "z")))
(let t13 (LoopIn t12 (Loop "0" (MMul (MNum 6) (MVar "b"))) (MMul (MNum 2) (MAdd (MMod (MVar "z") (MVar "b")) (MMul (MVar "b") (MAdd (MMod (MDiv (MVar "z") (MMax (MVar "b") (MNum 1))) (MNum 2)) (MMul (MNum 2) (MMod (MDiv (MVar "z") (MMax (MMul (MNum 2) (MVar "b")) (MNum 1))) (MNum 3)))))))))
(let t14 (LoopIn t13 (Loop "-pad1-" (MNum 1)) (MNum 0)))
(let t15 (LoopIn t14 (Loop "-pad2-" (MNum 1)) (MNum 0)))
(let t16 (LoopIn t15 (Loop "-pad3-" (MNum 1)) (MNum 0)))
(let t17 (LoopIn t16 (Loop "-pad4-" (MNum 1)) (MNum 0)))
(let t18 (LoopIn t17 (Loop "4" (MNum 2)) (MVar "z")))
(let t19 (Add t6 t18))
(let t20 (LoopOut t19 (Loop "4" (MNum 2)) (MAccum "a")))
(let t21 (LoopOut t20 (Loop "-pad4-" (MNum 1)) (MVar "z")))
(let t22 (LoopOut t21 (Loop "-pad3-" (MNum 1)) (MVar "z")))
(let t23 (LoopOut t22 (Loop "-pad2-" (MNum 1)) (MVar "z")))
(let t24 (LoopOut t23 (Loop "-pad1-" (MNum 1)) (MVar "z")))
(let t25 (LoopOut t24 (Loop "0" (MMul (MNum 6) (MVar "b"))) (MVar "z")))

(run 3)