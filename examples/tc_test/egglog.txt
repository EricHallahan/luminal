; -------- SYMBOLIC ALGEBRA -------
(ruleset expr)
(datatype Expression
	(MNum i64)
	(MVar String)
	(MAdd Expression Expression)
	(MSub Expression Expression)
	(MMul Expression Expression)
	(MDiv Expression Expression)
	(MMod Expression Expression)
	(MMin Expression Expression)
	(MMax Expression Expression)
	(MAnd Expression Expression)
	(MOr Expression Expression)
	(MGte Expression Expression)
	(MLt Expression Expression)
	(MFloorTo Expression Expression)
    (MReplace Expression Expression Expression)
    (MAccum String) ; this marks that we feed the output (also marked with MAccum) back in
)

; Communative
(rewrite (MAdd a b) (MAdd b a) :ruleset expr)
(rewrite (MMul a b) (MMul b a) :ruleset expr)

; Associative
(rewrite (MAdd (MAdd a b) c) (MAdd a (MAdd b c)) :ruleset expr)
(rewrite (MMul (MMul a b) c) (MMul a (MMul b c)) :ruleset expr)

; Constant folding
(rewrite (MAdd (MNum a) (MNum b)) (MNum (+ a b)) :ruleset expr)
(rewrite (MSub (MNum a) (MNum b)) (MNum (- a b)) :ruleset expr)
(rewrite (MMul (MNum a) (MNum b)) (MNum (* a b)) :when ((< a 10000) (< b 10000)) :ruleset expr)
(rewrite (MDiv (MNum a) (MNum b)) (MNum (/ a b)) :when ((!= 0 b) (= 0 (% a b))) :ruleset expr)
(rewrite (MMax (MNum a) (MNum b)) (MNum (max a b)) :ruleset expr)
(rewrite (MMin (MNum a) (MNum b)) (MNum (min a b)) :ruleset expr)
(rewrite (MAnd (MNum a) (MNum b)) (MNum (& a b)) :ruleset expr)

; Simple reductions
(rewrite (MAdd a (MNum 0)) a :ruleset expr)
(rewrite (MMul a (MNum 1)) a :ruleset expr)
(rewrite (MMul a (MNum 0)) (MNum 0) :ruleset expr)
(rewrite (MDiv a (MNum 1)) a :ruleset expr)
(rewrite (MMul (MDiv ?a ?b) ?b) (MFloorTo ?a ?b) :ruleset expr)
(rewrite (MAdd (MFloorTo ?a ?b) (MMod ?a ?b)) ?a :ruleset expr)
;(rewrite (MDiv ?a ?a) (MNum 1) :ruleset expr) ; why does this cause kernels to incorrectly oversimplify?
;(rewrite (MDiv (MMul ?x ?y) ?y) ?x :ruleset expr) ; and this?
(rewrite (MMod (MMul ?x ?y) ?y) (MNum 0) :ruleset expr)
(rewrite (MDiv (MMul ?x ?y) ?z) (MMul ?x (MDiv ?y ?z)) :ruleset expr)
(rewrite (MMod (MMod ?x (MNum ?y)) (MNum ?z)) (MMod ?x (MNum ?y)) :when ((>= ?z ?y) (= 0 (% ?y ?z))) :ruleset expr) ; nested mods
(rewrite (MMod (MMod ?x (MNum ?y)) (MNum ?z)) (MMod ?x (MNum ?z)) :when ((>= ?y ?z) (= 0 (% ?z ?y))) :ruleset expr)

; reduce contiguous multidimensional indexing
(rewrite
	(MAdd
		(MMul (MNum ?outerStride) (MMod (MDiv (MVar "z") (MNum ?innerSize)) (MNum ?outerSize)))
		(MMul (MNum ?innerStride) (MMod (MVar "z") (MNum ?innerSize)))
	)
	(MMul (MNum ?innerStride) (MMod (MVar "z") (MNum (* ?innerSize ?outerSize))))
	:ruleset expr
)


; Replacement
(rewrite (MReplace ?x ?y ?z) ?z :when ((= ?x ?y)) :ruleset expr)
(rewrite (MReplace (MAdd ?a ?b) ?x ?y) (MAdd (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)) :ruleset expr)
(rewrite (MReplace (MSub ?a ?b) ?x ?y) (MSub (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)) :ruleset expr)
(rewrite (MReplace (MMul ?a ?b) ?x ?y) (MMul (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)) :ruleset expr)
(rewrite (MReplace (MDiv ?a ?b) ?x ?y) (MDiv (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)) :ruleset expr)
(rewrite (MReplace (MMod ?a ?b) ?x ?y) (MMod (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)) :ruleset expr)
(rewrite (MReplace (MMin ?a ?b) ?x ?y) (MMin (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)) :ruleset expr)
(rewrite (MReplace (MMax ?a ?b) ?x ?y) (MMax (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)) :ruleset expr)
(rewrite (MReplace (MFloorTo ?a ?b) ?x ?y) (MFloorTo (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)) :ruleset expr)
; leave numbers unchanged
(rewrite (MReplace (MNum ?n) ?x ?y) (MNum ?n) :ruleset expr)
(rewrite (MReplace (MAccum ?acc) ?x ?y) (MAccum ?acc) :ruleset expr)

; leave other vars unchanged
(rewrite (MReplace (MVar ?v) (MVar ?x) ?y) (MVar ?v) :when ((!= ?v ?x)) :ruleset expr)

; reduce multi-dim squeezed indexing into simple multiplicative indexing
(rewrite
  (MAdd (MMul (MNum (* d n2)) (MMod (MDiv ?v (MNum d)) (MNum m)))
        (MMul (MNum n2) (MMod ?v (MNum d))))
  (MMul ?v (MNum n2))
	:ruleset expr
)

; -------- IR --------
(ruleset ir)
(ruleset ir-prop)
(ruleset ir-generic)
(datatype LoopType (Loop String Expression))
(datatype*
 	(IR
  		; General kernel stuff
     	(GMEM String)
     	(LoopIn IR LoopType Expression)
     	(LoopOut IR LoopType Expression)
      	(SMEM)
       	(SMEMLoad IR IR)
        (SMEMRead IR IR)

        ; Unary Ops
     	(Exp2 IR)
      	(Log2 IR)
    	(Sqrt IR)
     	(Sin IR)
      	(Recip IR)
       	(Neg IR)

        ; Binary Ops
     	(Add IR IR)
     	(Mul IR IR)
      	(Max IR IR)

        ; search helpers
        (Unary String IR)
     	(Binary String IR IR)

      	; propogation patterns
      	(SwapLoops IR LoopType LoopType) ; Swap two loops, identified by their strings
       	(TileLoop IR String) ; Tile a loop, identified by it's string
        (UnpadLoop IR String) ; Remove a padding loop, identified by it's string
        (MergeLoops IR String String) ; Merge loops, identified by their strings
		(TCMatmul IR IR Expression Expression Expression Expression Expression Expression) ; input A, input B, A k stride, B k stride, A inner stride, B inner stride, C inner stride, number of K tile loops

    	; propogation pattern helpers
     	(PropOneArg String IR String) ; Generic prop one arg back
     	(PropTwoArgs String IR String String) ; Generic prop two args back
     )
)

; -------------- HELPERS ---------------

; Convert to and from generic unary ops
(birewrite (Exp2 ?x) (Unary "Exp2" ?x) :ruleset ir-generic)
(birewrite (Log2 ?x) (Unary "Log2" ?x) :ruleset ir-generic)
(birewrite (Sqrt ?x) (Unary "Sqrt" ?x) :ruleset ir-generic)
(birewrite (Sin ?x) (Unary "Sin" ?x) :ruleset ir-generic)
(birewrite (Recip ?x) (Unary "Recip" ?x) :ruleset ir-generic)
(birewrite (Neg ?x) (Unary "Neg" ?x) :ruleset ir-generic)
(birewrite (Add ?a ?b) (Binary "Add" ?a ?b) :ruleset ir-generic)
(birewrite (Mul ?a ?b) (Binary "Mul" ?a ?b) :ruleset ir-generic)
(birewrite (Max ?a ?b) (Binary "Max" ?a ?b) :ruleset ir-generic)

; Communative binary ops
;(rewrite (Binary ?bin ?a ?b) (Binary ?bin ?b ?a) :ruleset ir)
; distributive/associative skeletons so sums and products re-associate
;(rewrite (Add (Add ?a ?b) ?c) (Add ?a (Add ?b ?c)) :ruleset ir)
;(rewrite (Mul (Mul ?a ?b) ?c) (Mul ?a (Mul ?b ?c)) :ruleset ir)

; ---------- RULES ----------

; remove pad loop
(rewrite
 	(LoopOut (Unary ?un (LoopIn ?x (Loop ?loop (MNum 1)) (MNum 0))) (Loop ?loop (MNum 1)) (MNum 0))
	(Unary ?un ?x)
	 :ruleset ir
)
(rewrite
 	(LoopOut (Binary ?bin (LoopIn ?a (Loop ?loop (MNum 1)) (MNum 0)) (LoopIn ?b (Loop ?loop (MNum 1)) (MNum  0))) (Loop ?loop (MNum 1)) (MNum 0))
	(Binary ?bin ?a ?b)
	 :ruleset ir
)
; add pad loop
(rewrite
	(LoopOut (Unary ?un ?x) (Loop ?l ?r) ?s)
	(LoopOut (LoopOut (Unary ?un (LoopIn ?x (Loop "newpad" (MNum 1)) (MNum 0))) (Loop "newpad" (MNum 1)) (MNum 0)) (Loop ?l ?r) ?s)
	:when ((!= ?r (MNum 1)) (!= ?s (MNum 0)))
	 :ruleset ir
)
(rewrite
	(LoopOut (Binary ?bin ?a ?b) (Loop ?l ?r) ?s)
	(LoopOut (LoopOut (Binary ?bin (LoopIn ?a (Loop "newpad" (MNum 1)) (MNum 0)) (LoopIn ?b (Loop "newpad" (MNum 1)) (MNum 0))) (Loop "newpad" (MNum 1)) (MNum 0)) (Loop ?l ?r) ?s)
	:when ((!= ?r (MNum 1)) (!= ?s (MNum 0)))
	 :ruleset ir
)
; remove unnessecary modulo
(rewrite (LoopIn ?x (Loop ?l ?range) (MMul ?st (MMod (MVar "z") ?range))) (LoopIn ?x (Loop ?l ?range) (MMul ?st (MVar "z"))) :ruleset expr)
(rewrite (LoopOut ?x (Loop ?l ?range) (MMul ?st (MMod (MVar "z") ?range))) (LoopOut ?x (Loop ?l ?range) (MMul ?st (MVar "z"))) :ruleset expr)

; Loop Fusion
;(rewrite (LoopIn (LoopOut ?x (Loop ?lo ?range) ?st) (Loop ?li ?range) ?st) ?x :ruleset ir)

(rewrite (LoopIn (LoopOut (Binary ?bin ?a ?b) (Loop ?loopA ?range) ?st) (Loop ?loopB ?range) ?st) (Binary ?bin ?a ?b) :ruleset ir)
(rewrite
	(LoopIn (LoopIn
		(LoopOut (LoopOut (Binary ?bin ?a ?b) (Loop ?loopA1 ?range1) ?st1) (Loop ?loopA2 ?range2) ?st2)
	(Loop ?loopB2 ?range2) ?st2) (Loop ?loopB1 ?range1) ?st1)
	(Binary ?bin ?a ?b)
	 :ruleset ir
)
(rewrite
	(LoopIn (LoopIn (LoopIn
		(LoopOut (LoopOut (LoopOut (Binary ?bin ?a ?b) (Loop ?loopA1 ?range1) ?st1) (Loop ?loopA2 ?range2) ?st2) (Loop ?loopA3 ?range3) ?st3)
	(Loop ?loopB3 ?range3) ?st3) (Loop ?loopB2 ?range2) ?st2) (Loop ?loopB1 ?range1) ?st1)
	(Binary ?bin ?a ?b)
	 :ruleset ir
)
(rewrite
	(LoopIn (LoopIn (LoopIn (LoopIn
		(LoopOut (LoopOut (LoopOut (LoopOut (Binary ?bin ?a ?b) (Loop ?loopA1 ?range1) ?st1) (Loop ?loopA2 ?range2) ?st2) (Loop ?loopA3 ?range3) ?st3) (Loop ?loopA4 ?range4) ?st4)
	(Loop ?loopB4 ?range4) ?st4) (Loop ?loopB3 ?range3) ?st3) (Loop ?loopB2 ?range2) ?st2) (Loop ?loopB1 ?range1) ?st1)
	(Binary ?bin ?a ?b)
	 :ruleset ir
)

; Specialized swap loops
(rewrite
	(LoopOut
		(LoopOut
			(Binary ?bin
				(LoopIn
					(LoopIn ?a (Loop ?outL ?out) ?outASt)
					(Loop ?inL ?in)
					?inASt
				)
				(LoopIn
					(LoopIn ?b (Loop ?outL ?out) ?outBSt)
					(Loop ?inL ?in)
					?inBSt
				)
			)
			(Loop ?inL ?in)
			?inSt
		)
		(Loop ?outL ?out)
		?outSt
	)
	(LoopOut
		(LoopOut
			(Binary ?bin
				(LoopIn
					(LoopIn ?a (Loop ?inL ?in) ?inASt)
					(Loop ?outL ?out)
					?outASt
				)
				(LoopIn
					(LoopIn ?b (Loop ?inL ?in) ?inBSt)
					(Loop ?outL ?out)
					?outBSt
				)
			)
			(Loop ?outL ?out)
			?outSt
		)
		(Loop ?inL ?in)
		?inSt
	)
	 :ruleset ir
)

; Tiling
(let tileFactor 8)
(rewrite
	(LoopOut ?body (Loop ?loop (MNum ?range)) ?stride)
	(LoopOut
		(LoopOut
			(TileLoop ?body ?loop)
			(Loop (+ ?loop "_tile") (MNum tileFactor))
			?stride
		)
		(Loop (+ ?loop "_out") (MNum (/ ?range tileFactor)))
		(MReplace ?stride (MVar "z") (MMul (MVar "z") (MNum tileFactor)))
	)
	:when ((> ?range tileFactor) (= (% ?range tileFactor) 0))
	:ruleset ir
)
(rewrite
	(TileLoop (LoopIn ?body (Loop ?loop (MNum ?range)) ?stride) ?loop)
	(LoopIn
		(LoopIn ?body
			(Loop (+ ?loop "_out") (MNum (/ ?range tileFactor)))
			(MReplace ?stride (MVar "z") (MMul (MVar "z") (MNum tileFactor)))
		)
		(Loop (+ ?loop "_tile") (MNum tileFactor))
		?stride
	)
	:ruleset ir-prop
)
; propogation
(rewrite
	(TileLoop (LoopIn ?body (Loop ?other ?range) ?stride) ?loop)
	(LoopIn (TileLoop ?body ?loop) (Loop ?other ?range) ?stride)
	:when ((!= ?loop ?other))
	 :ruleset ir-prop
)
(rewrite
	(TileLoop (LoopOut ?body (Loop ?other ?range) ?stride) ?loop)
	(LoopOut (TileLoop ?body ?loop) (Loop ?other ?range) ?stride)
	 :ruleset ir-prop
)
(rewrite
	(TileLoop (Unary ?un ?body) ?loop)
	(Unary ?un (TileLoop ?body ?loop))
	 :ruleset ir-prop
)
(rewrite
	(TileLoop (Binary ?bin ?bodyA ?bodyB) ?loop)
	(Binary ?bin (TileLoop ?bodyA ?loop) (TileLoop ?bodyB ?loop))
	 :ruleset ir-prop
)

; Loop merging
;(rewrite
;	(LoopOut
;		(LoopOut ?x
;			(Loop ?i ?rangeI) ?stI
;		)
;		(Loop ?o ?rangeO) ?stO
;	)
;	(LoopOut (MergeLoops ?x ?o ?i)
;		(Loop (+ ?o ?i) (MMul ?rangeO ?rangeI))
;		(MAdd (MReplace ?stO (MVar "z") (MDiv (MVar "z") ?rangeI)) (MReplace ?stI (MVar "z") (MMod (MVar "z") ?rangeI)))
;	)
;	 :ruleset ir
;)
(rewrite
	(MergeLoops
		(LoopIn
			(LoopIn
				?x
				(Loop ?o ?rangeO) ?stO
			)
			(Loop ?i ?rangeI) ?stI
		)
		?o ?i
	)
	(LoopIn
		?x
		(Loop (+ ?o ?i) (MMul ?rangeO ?rangeI))
		(MAdd (MReplace ?stO (MVar "z") (MDiv (MVar "z") ?rangeI)) (MReplace ?stI (MVar "z") (MMod (MVar "z") ?rangeI)))
	)
	 :ruleset ir-prop
)
; propogation
(rewrite
	(MergeLoops (LoopIn ?body (Loop ?other ?range) ?stride) ?o ?i)
	(LoopIn (MergeLoops ?body ?o ?i) (Loop ?other ?range) ?stride)
	:when ((!= ?i ?other))
	 :ruleset ir-prop
)
(rewrite
	(MergeLoops (LoopOut ?body (Loop ?other ?range) ?stride) ?o ?i)
	(LoopOut (MergeLoops ?body ?o ?i) (Loop ?other ?range) ?stride)
	 :ruleset ir-prop
)
(rewrite
	(MergeLoops (Unary ?un ?body) ?o ?i)
	(Unary ?un (MergeLoops ?body ?o ?i))
	 :ruleset ir-prop
)
(rewrite
	(MergeLoops (Binary ?bin ?bodyA ?bodyB) ?o ?i)
	(Binary ?bin (MergeLoops ?bodyA ?o ?i) (MergeLoops ?bodyB ?o ?i))
	 :ruleset ir-prop
)

; TensorCore
(rewrite
	(LoopOut ; m tile
		(LoopOut ; n tile
			 (LoopOut ; k outer
				(LoopOut ; k tile
					(Add
						(Mul
							; input A
							(LoopIn ; k tile
								(LoopIn ; k outer
									(LoopIn ; n tile
										(LoopIn ; m tile
											?a
											(Loop ?loop_a_mtile (MNum 8))
											(MMul (MVar "z") (MNum ?k))
										)
										(Loop ?loop_a_ntile (MNum 8))
										(MNum 0)
									)
									(Loop ?loop_a_kouter ?k_loops)
									(MMul (MVar "z") (MNum 8))
								)
								(Loop ?loop_a_kinner (MNum 8))
								(MVar "z")
							)
							; input B
							(LoopIn ; k tile
								(LoopIn ; k outer
									(LoopIn ; n tile
										(LoopIn ; m tile
											?b
											(Loop ?loop_b_mtile (MNum 8))
											(MNum 0)
										)
										(Loop ?loop_b_ntile (MNum 8))
										(MVar "z")
									)
									(Loop ?loop_b_kouter ?k_loops)
									(MMul (MVar "z") (MNum (* ?n 8)))
								)
								(Loop ?loop_b_kinner (MNum 8))
								(MMul (MVar "z") (MNum ?n))
							)
						)
						; accumulator
						(LoopIn ; k tile
							(LoopIn ; k outer
								(LoopIn ; n tile
									(LoopIn ; m tile
										?acc
										(Loop ?loop_acc_mtile (MNum 8))
										(MNum 0)
									)
									(Loop ?loop_acc_ntile (MNum 8))
									(MNum 0)
								)
								(Loop ?loop_acc_kouter ?k_loops)
								(MAccum ?acc_outer)
							)
							(Loop ?loop_acc_kinner (MNum 8))
							(MAccum ?acc_inner)
						)
					)
					(Loop ?loop_a_kinner (MNum 8))
					(MAccum ?acc_inner)
				)
				(Loop ?loop_a_kouter ?k_loops)
				(MAccum ?acc_outer)
			)
			(Loop ?loop_a_ntile (MNum 8))
			(MVar "z")
		)
		(Loop ?loop_a_mtile (MNum 8))
		(MMul (MVar "z") (MNum ?n))
	)
	(LoopOut ; m tile
		(LoopOut ; n tile
			(TCMatmul
				; a
				(LoopIn ; n tile
					(LoopIn ; m tile
						?a
						(Loop ?loop_a_mtile (MNum 8))
						(MNum 0)
					)
					(Loop ?loop_a_ntile (MNum 4))  ; each thread in the matmul does 2 elements
					(MNum 0)
				)
				; b
				(LoopIn ; n tile
					(LoopIn ; m tile
						?b
						(Loop ?loop_b_mtile (MNum 8))
						(MNum 0)
					)
					(Loop ?loop_b_ntile (MNum 4))  ; each thread in the matmul does 2 elements
					(MNum 0)
				)
				; a k stride
				(MMul (MVar "z") (MNum 8))
				; b k stride
				(MMul (MVar "z") (MNum (* ?n 8)))
				; a row size
				(MNum ?k)
				; b row size
				(MNum ?n)
				; c row size
				(MNum ?n)
				; k loops
				?k_loops
			)
			(Loop ?loop_a_ntile (MNum 4))
			(MNum 0)
		)
		(Loop ?loop_a_mtile (MNum 8))
		(MNum 0)
	)
	:ruleset ir
)

; Swap loops
(ruleset swap)
(rewrite
	(LoopOut (LoopOut ?x ?innerLoop ?innerStride) ?outerLoop ?outerStride)
	(LoopOut (LoopOut (SwapLoops ?x ?innerLoop ?outerLoop) ?outerLoop ?outerStride) ?innerLoop ?innerStride)
	:ruleset swap
)
(rewrite
	(SwapLoops (LoopIn (LoopIn ?x ?outerLoop ?outerStride) ?innerLoop ?innerStride) ?innerLoop ?outerLoop)
	(LoopIn (LoopIn ?x ?innerLoop ?innerStride) ?outerLoop ?outerStride)
	:ruleset ir-prop
)
; propogate
(rewrite
	(SwapLoops (LoopOut ?x ?loop ?stride) ?innerLoop ?outerLoop)
	(LoopOut (SwapLoops ?x ?innerLoop ?outerLoop) ?loop ?stride)
	:ruleset ir-prop
)
(rewrite
	(SwapLoops (LoopIn ?x ?loop ?stride) ?innerLoop ?outerLoop)
	(LoopIn (SwapLoops ?x ?innerLoop ?outerLoop) ?loop ?stride)
	:when ((!= ?loop ?outerLoop))
	:ruleset ir-prop
)
(rewrite
	(SwapLoops (Binary ?bin ?a ?b) ?innerLoop ?outerLoop)
	(Binary ?bin (SwapLoops ?a ?innerLoop ?outerLoop) (SwapLoops ?b ?innerLoop ?outerLoop))
	:ruleset ir-prop
)

(let t0 (GMEM "A"))
(let t1 (LoopIn t0 (Loop "m" (MNum 64)) (MMul (MVar "z") (MNum 64))))
(let t2 (LoopIn t1 (Loop "n" (MNum 64)) (MNum 0)))
(let t3 (LoopIn t2 (Loop "k" (MNum 64)) (MVar "z")))
(let t4 (GMEM "B"))
(let t5 (LoopIn t4 (Loop "m" (MNum 64)) (MNum 0)))
(let t6 (LoopIn t5 (Loop "n" (MNum 64)) (MVar "z")))
(let t7 (LoopIn t6 (Loop "k" (MNum 64)) (MMul (MVar "z") (MNum 64))))
(let t8 (GMEM "acc"))
(let t9 (LoopIn t8 (Loop "m" (MNum 64)) (MNum 0)))
(let t10 (LoopIn t9 (Loop "n" (MNum 64)) (MNum 0)))
(let t11 (LoopIn t10 (Loop "k" (MNum 64)) (MAccum "a")))
(let t12 (Mul t3 t7))
(let t13 (Add t12 t11))
(let t14 (LoopOut t13 (Loop "k" (MNum 64)) (MAccum "a")))
(let t15 (LoopOut t14 (Loop "n" (MNum 64)) (MVar "z")))
(let t16 (LoopOut t15 (Loop "m" (MNum 64)) (MMul (MVar "z") (MNum 64))))

(run-schedule
	(run ir-generic)
	(run ir) ; run ir rules once
	(repeat 4 swap) ; run swap every other run
	(repeat 10 ir-prop)
	(repeat 5 expr)
	(repeat 5 ir-prop)
	(repeat 5 expr)
	(repeat 5 ir-prop)
	(repeat 5 expr)
	(repeat 5 ir-prop)
	(repeat 5 expr)
	;(run ir)
	(repeat 1 ir-generic)
)

(let a_gmem (GMEM "A"))
(let a_m_outer (LoopIn a_gmem (Loop "m_outer" (MNum 8)) (MMul (MMul (MVar "z") (MNum 64)) (MNum 8))))
(let a_n_outer (LoopIn a_m_outer (Loop "n_outer" (MNum 8)) (MNum 0)))
(let a_m_tile (LoopIn a_n_outer (Loop "m_tile" (MNum 8)) (MMul (MVar "z") (MNum 64))))
(let a_n_tile (LoopIn a_m_tile (Loop "n_tile" (MNum 8)) (MNum 0)))
(let a_k_outer (LoopIn a_n_tile (Loop "" (MNum 8)) (MMul (MVar "z") (MNum 8))))
(let a_k_inner (LoopIn a_k_outer (Loop "" (MNum 8)) (MVar "z")))

(let b_gmem (GMEM "B"))
(let b_m_outer (LoopIn b_gmem (Loop "m_outer" (MNum 8)) (MNum 0)))
(let b_n_outer (LoopIn b_m_outer (Loop "n_outer" (MNum 8)) (MMul (MVar "z") (MNum 8))))
(let b_m_tile (LoopIn b_n_outer (Loop "m_tile" (MNum 8)) (MNum 0)))
(let b_n_tile (LoopIn b_m_tile (Loop "n_tile" (MNum 8)) (MVar "z")))
(let b_k_outer (LoopIn b_n_tile (Loop "" (MNum 8)) (MMul (MVar "z") (MNum 512))))
(let b_k_inner (LoopIn b_k_outer (Loop "" (MNum 8)) (MMul (MVar "z") (MNum 64))))

(let acc_gmem (GMEM "acc"))
(let acc_m_outer (LoopIn acc_gmem (Loop "m_outer" (MNum 8)) (MNum 0)))
(let acc_n_outer (LoopIn acc_m_outer (Loop "n_outer" (MNum 8)) (MNum 0)))
(let acc_m_tile (LoopIn acc_n_outer (Loop "m_tile" (MNum 8)) (MNum 0)))
(let acc_n_tile (LoopIn acc_m_tile (Loop "n_tile" (MNum 8)) (MNum 0)))
(let acc_k_outer (LoopIn acc_n_tile (Loop "" (MNum 8)) (MAccum "a")))
(let acc_k_inner (LoopIn acc_k_outer (Loop "" (MNum 8)) (MAccum "a")))

(let mul_k_outer (Mul a_k_inner b_k_inner))
(let add_k_outer (Add mul_k_outer acc_k_inner))

(let out_k_inner (LoopOut add_k_outer (Loop "" (MNum 8)) (MAccum "a")))
(let out_k_outer (LoopOut out_k_inner (Loop "" (MNum 8)) (MAccum "a")))
(let out_n_tile (LoopOut out_k_outer (Loop "n_tile" (MNum 8)) (MVar "z")))
(let out_m_tile (LoopOut out_n_tile (Loop "m_tile" (MNum 8)) (MMul (MVar "z") (MNum 64))))
(let out_n_outer (LoopOut out_m_tile (Loop "n_outer" (MNum 8)) (MMul (MVar "z") (MNum 8))))
(let out_m_outer (LoopOut out_n_outer (Loop "m_outer" (MNum 8)) (MMul (MMul (MVar "z") (MNum 8)) (MNum 64))))

(ruleset a-rule)
(rewrite (Loop ?x ?r) (Loop "" ?r) :ruleset a-rule)
(rewrite (TileLoop ?x ?l) (TileLoop ?x "") :ruleset a-rule)
(rewrite (MergeLoops ?x ?l ?o) (MergeLoops ?x "" "") :ruleset a-rule)
(run-schedule (saturate a-rule))

(check (= out_m_outer t16))